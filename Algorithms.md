# Algorithms



# 概述

* 是指令的集合,是为解决特定问题而规定的一系列操作
* 它是明确定义的可计算过程,以一个数据集合作为输入,并产生一个数据集合作为输出
* 一个算法通常来说具有以下五个特性
  * 输入:一个算法应以待解决的问题的信息作为输入
  * 输出:输入对应指令集处理后得到的信息
  * 可行性:算法是可行的,即算法中的每一条指令都是可以实现的,均能在有限的时间内完成
  * 有穷性:算法执行的指令个数是有限的,每个指令又是在有限时间内完成的,因此整个算法也是在有限时间内可以结束的
  * 确定性:算法对于特定的合法输入,其对应的输出是唯一的.即当算法从一个特定输入开始,多次执行同一指令集结果总是相同的
* 简单的说,算法就是计算机解题的过程,在这个过程中,无论是形成解题思路还是编写程序,都是在实施某种算法.前者是算法的逻辑形式,后者是算法的代码形式
* 评价算法优劣的依据:时间复杂度和空间复杂度
  * 时间复杂度:执行算法所需要的计算工作量
  * 空间复杂度:执行这个算法所需要的内存空间



# 复杂度

## 时间复杂度



### 时间频度

* 一个算法花费的时间与算法中语句的执行次数成正比例,哪个算法中语句执行次数多,它花费时间就多
* 一个算法中的语句执行次数称为语句频度或时间频度,表示为T(n),n表示问题的规模



### 时间复杂度

* 要知道算法变化时呈现什么规律,以及问题的规模,而不是具体的次数,此时引入时间复杂度
* 一般情况下,算法中基本操作重复执行的次数是问题规模n的某个函数,用T(n)表示,若有某个辅助函数f(n),使得当n趋近于无穷大时,T(n)/f(n)的极限值为不等于零的常数,则称f(n)是T(n)的同数量级函数
* 记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度,简称时间复杂度.或者说时间复杂度就是时间频度去掉低阶项和首项常数
* 时间频度与时间复杂度是不同的,时间频度不同但时间复杂度可能相同
  * 如:某两个算法的时间频度是 T(n) = 100000n2+10n+6->T(n) = 10n2+10n+6->T(n) = n2,但是时间复杂度都是 T(n) = O(n2)
* 最坏时间复杂度:最坏情况下的时间复杂度称最坏时间复杂度,一般不特别说明,讨论的时间复杂度均是最坏情况下的时间复杂度
  * 这样做的原因是最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界,这就保证了算法的运行时间不会比任何更长
  * 在最坏情况下的时间复杂度为T(n)=O(n),它表示对于任何输入实例,该算法的运行时间不可能大于O(n)
* 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下,算法的期望运行时间.鉴于平均复杂度难计算,且有很多算法的平均情况和最差情况的复杂度是一样的,所以一般讨论最坏时间复杂度
* 为了进一步说明算法的时间复杂度,定义Ο,Ω,Θ符号
  * Ο:欧米可荣,符号给出了算法时间复杂度的上界(最坏情况<=),比如T(n) =O(n2)
  * Ω:欧米伽,符号给出了时间复杂度的下界(最好情况>=),比如T(n) =Ω(n2)
  * Θ:西塔,给出了算法时间复杂度的精确阶(最好和最坏是同一个阶=),比如T(n) =Θ(n2)



### 时间复杂度计算

* 无需计算时间频度,即使计算处理还要忽略常量,低次幂和最高次幂的系数,所以可以采用如下简单方法
  * 找出算法中的基本语句:算法中执行次数最多的那条语句就是基本语句,通常是最内层循环的循环体
  * 计算基本语句的执行次数的数量级:只需计算基本语句执行次数的数量级,这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可,可以忽略所有低次幂和最高次幂的系数.这样能够简化算法分析,并且使注意力集中在最重要的一点上:增长率
  * 用大Ο记号表示算法的时间性能:将基本语句执行次数的数量级放入大Ο记号中

```java
// 一个简单语句的时间复杂度为O(1)
int count=0;

// 100个简单语句的时间复杂度也为O(1),100是常数,不是趋向无穷大的n
int count=0;

// 一个循环的时间复杂度为O(n),T(n)=O(n)
int n=8, count=0;
for (int i=1; i<=n; i++)
   count++;

// 时间复杂度为O(log2 n)的循环语句
int n=8, count=0;
for (int i=1; i<=n; i*=2)
   count++;

// 时间复杂度为O(n2)的二重循环
int n=8, count=0;
for (int i=1; i<=100n; i++)
   for (int j=1; j<=10n; j++)
       count++;

// 时间复杂度为O(nlog2n)的二重循环
int n=8, count=0;
for (int i=1; i<=n; i*=2)
   for (int j=1; j<=n; j++)
       count++;

// 时间复杂度为O(n2)的二重循环
int n=8, count=0;
for (int i=1; i<=n; i++)
   for (int j=1; j<=i; j++)
       count++;
// 1+2+3+4....+n=(1+n)*n/2
// 需要复杂些数学运算:1+2+3+.....+n=(n+1)*n/2  时间复杂度是 O(n2)
```



### 时间复杂度级别

* 常数阶O(1)
* 对数阶O(log2n)
* 线性阶O(n)
* 线性对数阶O(n*log2n)
* 平方阶O(n2)
* 立方阶O(n3)
* k次方阶O(nk)
* 指数阶O(2n)
* 阶乘阶O(n!)
* 上面各种时间复杂度级别,执行效率越来越低



## 空间复杂度

* 算法的存储量包括
  * 程序本身所占空间
  * 输入数据所占空间
  * 辅助变量所占空间

* 输入数据所占空间只取决于问题本身,和算法无关,只需要分析除输入和程序之外的辅助变量所占额外空间
* 空间复杂度是对一个算法在运行过程中临时占用的存储空间大小的量度,一般也作为问题规模n的函数,以数量级形式给出,记作S(n) = O(g(n))
* 空间复杂度相比时间复杂度分析要少
* 递归代码一般都比较简短,算法本身所占用的存储空间较少,但运行时需要占用较多的临时工作单元
* 非递归算法代码一般可能比较长,算法本身占用的存储空间较多,但运行时将可能需要较少的存储单元

```java
// 由于算法中临时变量的个数与问题规模n无关,所以空间复杂度均为S(n)=O(1)
int fun(int n){  
    int i,j,k,s;
    s=0;
    for (i=0;i<=n;i++)          
        for (j=0;j<=i;j++)          
            for (k=0;k<=j;k++)    
                s++;
    return(s);
}

// 此属于递归算法(后续讲解),每次调用本身都要分配空间,fun(a,n,0)的空间复杂度为O(n)
void fun(int a[],int n,int k){
    //数组a共有n个元素
    int i;
    if (k==n-1)
        for (i=0;i<n;i++)　　
            printf("%d\n",a[i]);  //执行n次
    else{
      for (i=k;i<n;i++)
        a[i]=a[i]+i*i;        　　//执行n-k次
     fun(a,n,k+1);
    }
}
```



# 数据结构

* 数据结构是指相互之间存在一种或多种特定关系的数据元素的集合,表示一组数据元素及其相互关系的数据结构有两种不同的表现形式:
  * 一种是数据结构的逻辑层面,即数据的逻辑结构
  * 一种是存在于计算机世界的物理层面,即数据的存储结构
  * 数据结构=逻辑结构+存储结构
  * 数据结构=逻辑结构+存储结构+(在存储结构上的)运算/操作
* 集合结构:就是数学中所学习的集合,集合中的元素有三个特征:
  * 确定性:集合中的元素必须是确定的
  * 唯一性:集合中的元素互不相同,例如:集合A={1,a},则a不能等于1
  * 无序性:集合中的元素没有先后之分,如集合{3,4,5}和{3,5,4}算作同一个集合
* 线性结构:有且只有一个开始和终端节点,并且所有节点都最多只有一个直接前驱和一个直接后继.数据元素之间存在着一对一的线性关系的数据结构
  * 集合中必存在唯一的一个"第一个元素"
  * 集合中必存在唯一的一个"最后的元素"
  * 除最后元素之外,其它数据元素均有唯一的"直接后继"
  * 除第一元素之外,其它数据元素均有唯一的"直接前驱"
* 树状结构:除了一个数据元素以外每个数据元素有且仅有一个直接前驱元素,但可以有多个直接后续元素.数据元素之间是一对多的联系,如二叉树
* 网络结构:每个数据元素可以有多个直接前驱元素,也可以有多给直接后续元素,数据元素之间是多对多
* 数据的存储结构主要包含数据元素本身的存储以及数据元素之间关系表示,常见的存储结构有顺序存储,链式存储,索引存储,散列存储



# 存储结构



## 顺序存储

* 把逻辑上相邻的节点存储在物理位置上相邻的存储单元中,节点之间逻辑关系由存储单元的邻接关系体现
* 数据元素的存储对应于一块连续的存储空间,数据元素之间的前驱和后续关系通过数据元素在存储器中的相对位置来反映
* 优点:节省存储空间,因为分配给数据的存储单元全用于存放数据,节点之间的逻辑关系没有占用额外的空间
* 缺点:插入和删除操作需要移动元素,效率低



## 链式存储

* 数据元素的存储对应的是不连续的存储空间,每个存储节点对应一个需要存储的数据元素
* 每个节点由数据域和指针域组成,元素之间的逻辑关系通过存储节点之间的链接关系反应
* 比顺序结构的存储密度小,每个节点都由数据域和指针域组成,所以相同空间全存满比链式存储更多
* 逻辑上相邻的节点物理上不必相邻
* 插入,删除灵活,不必移动节点,只要改变节点中的指针
* 查找节点时链接存储要比顺序存储慢
* 有元素才会分配节点空间,不会有闲置的节点



## 索引存储

* 除建立存储节点信息外,还建立附加的索引表来标识节点地址



## 散列存储

* 根据节点的关键字直接计算出该节点的存储地址,HashSet HashMap,添加,查询速度快



# 线性结构



## 线性表-linear list

* 线性表是n个类型相同数据元素的有限序列,通常记作(a0 , a1 , …ai-1 , ai , ai+1 …,an-1)
* 相同数据类型:这意味着在内存中存储时,每个元素会占用相同的内存空间,便于后续的查询定位
* 序列(顺序性):在线性表的相邻数据元素之间存在着序偶关系:
  * ai-1是ai的直接前驱,则a i是ai-1的直接后续,同时ai又是ai+1 的直接前驱,ai+1 是ai 的直接后续
  * 唯一没有直接前驱的元素a0一端称为表头,唯一没有后续的元素an-1一端称为表尾
  * 除了表头和表尾元素外,任何一个元素都有且仅有一个直接前驱和直接后继
* 有限
  * 线性表中数据元素的个数n定义为线性表的长度,n是一个有限值
  * 当n=0时线性表为空表
  * 在非空的线性表中每个数据元素在线性表中都有唯一确定的序号,例如a0的序号是0,ai的序号是i
  * 在一个具有n>0个数据元素的线性表中,数据元素序号的范围是[0, n-1]



### 线性表存储结构

* 顺序存储结构:在内存中分配连续的空间,只存储数据,不需要存储地址信息,位置就隐含着地址
  * 节省存储空间,因为分配给数据的存储单元全用存放结点的数据(不考虑c/c++语言中数组需指定大小的情况),结点之间的逻辑关系没有占用额外的存储空间
  * 索引查找效率高,即每一个结点对应一个序号,由该序号可以直接计算出来结点的存储地址
  * 假设线性表的每个数据元素需占用K个存储单元,并以元素所占的第一个存储单元的地址作为数据元素的存储地址,则线性表中序号为i的数据元素的存储地址LOC(ai)与序号为i+1的数据元素的存储地址LOC(ai+1)之间的关系为:LOC(ai+1) = LOC(ai) + K
  * 通常来说,线性表的i号元素a i 的存储地址为:LOC(ai) = LOC(a0) + i×K.其中LOC(a0)为0号元素a0 的存储地址,通常称为线性表的起始地址
  * 插入和删除操作需要移动元素,效率较低
  * 必须提前分配固定数量的空间,如果存储元素少,可能导致空闲浪费
  * 按照内容查询效率低,因为需要逐个比较判断



### 链表存储结构

* 数据元素的存储对应的是不连续的存储空间,每个存储结点对应一个需要存储的数据元素
* 每个结点是由数据域和指针域组成
* 元素之间的逻辑关系通过存储节点之间的链接关系反映出来
* 逻辑上相邻的节点物理上不必相邻
* 比顺序存储结构的存储密度小(每个节点都由数据域和指针域组成,所以相同空间内假设全存满的话顺序比链式存储更多)
* 查找结点时链式存储要比顺序存储慢(每个节点地址不连续,无规律,导致按照索引查询效率低下)
* 插入,删除灵活(不必移动节点,只要改变节点中的指针,但是需要先定位到元素上)
* 有元素才会分配结点空间,不会有闲置的节点