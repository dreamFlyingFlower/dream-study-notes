# Business



# 订单支付



![](img/001.png)



* 上图一个简化的下单流程,首先是提交订单,然后是支付
* 支付一般是走支付网关(支付中心),然后支付中心与第三方支付渠道(微信、支付宝、银联)交互
* 支付成功以后,异步通知支付中心,支付中心更新自身支付订单状态,再通知业务应用,各业务再更新各自订单状态
* 这个过程中经常可能遇到的问题是掉单,无论是超时未收到回调通知也好,还是程序自身报错也好
* 总之由于各种各样的原因,没有如期收到通知并正确的处理后续逻辑等等,都会造成用户支付成功了,但是服务端这边订单状态没更新
* 这个时候有可能产生投诉,或者用户重复支付
* 由于③⑤造成的掉单称之为外部掉单,由④⑥造成的掉单我们称之为内部掉单



## 支付掉单



* 支付订单增加一个中间状态支付中,当同一个订单去支付的时候,先检查有没有状态为支付中的支付流水,当然支付的时候要加个锁,支付完成以后更新支付流水状态的时候再讲其改成支付成功状态
* 支付中心这边要自己定义一个超时时间,在此时间范围内如果没有收到支付成功回调,则应调用接口主动查询支付结果,比如10s、20s、30s查一次,如果在最大查询次数内没有查到结果,应做异常处理
* 支付中心收到支付结果以后,将结果同步给业务系统,可以发MQ,也可以直接调用,直接调用的话要加重试
* 无论是支付中心,还是业务应用,在接收支付结果通知时都要考虑接口幂等性,消息只处理一次,其余的忽略
* 业务应用也应做超时主动查询支付结果
* 超时主动查询可以在发起支付的时候将这些支付订单放到一张表中,用定时任务去扫或者使用MQ



## 订单重复提交



* 创建订单时,用订单信息计算一个哈希值,判断redis中是否有key,有则不允许重复提交,没有则生成一个新key,放到redis中设置过期时间,然后创建订单



## 库存增减



### 下单减库存



* 即用户下单成功时减少库存数量
* 优势: 用户体验友好,系统逻辑简洁
* 缺点: 会导致恶意下单或下单后却不买,使得真正有需求的用户无法购买,影响真实销量
* 解决办法: 
  * 设置订单有效时间,若订单创建成功N分钟不付款,则订单取消,库存回滚
  * 限购,用各种条件来限制买家的购买件数,比如一个账号、一个ip,只能买一件
  * 风控,从技术角度进行判断,屏蔽恶意账号,禁止恶意账号购买



### 付款减库存



* 即用户支付完成并反馈给平台后再减少库存数量
* 优势: 减少无效订单带来的资源损耗
* 缺点: 因第三方支付返回结果存在时差,同一时间多个用户同时付款成功,会导致下单数目超过库存,商家库存不足容易引发断货和投诉,成本增加
* 解决办法: 
  * 付款前再次校验库存,如确认订单要付款时再验证一次,并友好提示用户库存不足
  * 增加提示信息: 在商品详情页,订单步骤页面提示不及时付款,不能保证有库存等



### 使用场景



* 两种方式各有优缺点,需结合实际场景进行考虑.如: 秒杀、抢购、促销活动等,可使用下单减库存的方式.而对于产品库存量大,并发流量不高的产品使用付款减库存的方式



## 微信支付简易流程



![](img/002.png)



# 幂等性



* 数据库建立唯一性索引,可以保证最终插入数据库的只有一条数据
* token机制,每次接口请求前先获取一个token,然后再下次请求的时候在请求的header体中加上这个token,后台进行验证,如果验证通过删除token,下次请求再次判断token
* 悲观锁或者乐观锁,悲观锁可以保证每次for update的时候其他sql无法update数据(在数据库引擎是innodb的时候,select的条件必须是唯一索引,防止锁全表)
* 先查询后判断,首先通过查询数据库是否存在数据,如果存在证明已经请求过了,直接拒绝该请求,如果没有存在,就证明是第一次进来,直接放行



## Redis实现幂等



![](img/003.png)



# 白名单



* Nginx实现白名单,配置完需要重启
  * allow: 允许访问,即白名单.allow必须放在deny前面,否则会无效
  * deny: 禁止访问,即黑名单

```nginx
http{
    # http模块
    allow 192.168.1.11;
    allow 192.168.1.12;
    deny all;

    server {
        # server模块
        allow 192.168.1.11
        allow 192.168.1.12;
        deny all;

        location /api {
            # location模块
            allow 192.168.1.13;
            deny all;
        }

        location /manage {
            allow 192.168.183.89;
            deny all;
        }
    }
}
```



# MySQL与ES同步



## Canel





* 原理是伪装成 MySQL 的从节点,从而订阅 master 节点的 Binlog 日志,主要流程为
* Canal 服务端向 MySQL 的 master 节点传输 dump 协议
* MySQL 的 master 节点接收到 dump 请求后推送 Binlog 日志给 Canal 服务端,解析 Binlog 对象(原始为 byte 流)转成 Json 格式
* Canal 客户端通过 TCP 协议或 MQ 形式监听 Canal 服务端,同步数据到 ES



# 高并发系统设计



## 页面静态化



* 用户每次访问页面时,都通过服务器动态渲染,会导致服务端承受过大的压力,而导致页面无法正常加载
* 使用`Freemarker`或`Velocity`模板引擎,实现页面静态化功能
* 以商城官网首页为例,可以在`Job`中,每隔一段时间,查出所有需要在首页展示的数据,汇总到一起,使用模板引擎生成到html文件当中
* 然后将该`html`文件,通过`shell`脚本,自动同步到前端页面相关的服务器上



## CDN加速



* 单单使用页面静态化还不够,因为用户分布在全国各地,地域相差很远,访问网站的网速各不相同

* CDN:Content Delivery Network,即内容分发网络.使用户就近获取所需内容,降低网络拥塞,提高用户访问响应速度和命中率
* CDN原理:将网站的静态内容复制并存储到分布在全球各地的服务器节点上,当用户请求访问网站时,CDN系统会根据用户的地理位置,自动将内容分发给离用户最近的服务器,从而实现快速访问
* 国内常见的CDN提供商有阿里云CDN、腾讯云CDN、百度云加速等



## 缓存



* 目前缓存有两种:
  * 基于应用服务器的内存缓存,也就是CPU二级缓存
  * 使用缓存中间件,比如:Redis、Memcached等,这种是分布式缓存
* 这两种缓存各有优缺点
  * 二级缓存的性能更好,但因为是基于应用服务器内存的缓存,如果系统部署到了多个节点,可能会存在数据不一致的情况
  * Redis或Memcached性能上比不上二级缓存,但它们是分布式缓存,避免多个服务器节点数据不一致的问题
* 使用缓存之后,可以减轻访问数据库的压力,显著的提升系统的性能
* 缓存也会带来了一些新的问题,比如:数据库和缓存双向数据库一致性问题,缓存穿透、击穿和雪崩问题等



## 异步



* 异步的原则:核心逻辑可以同步执行,同步写库;非核心逻辑,可以异步执行,异步写库
* 通常异步主要有两种:多线程 和 mq



### 线程池



* 使用线程池有个小问题:如果服务器重启或者是需要被执行的功能出现异常了,无法重试,会丢数据



### MQ



* 通常MQ不会丢消息,但是会有额外的部署以及性能消耗



## 多线程处理



* 使用多线程消费消息,可能会出现消息的顺序问题以及事务问题



## 分库分表



* 分库分表主要有两个方向：`垂直`和`水平`
  * 垂直:即业务方向更简单
  * 水平:即数据方向上,分库和分表的作用,其实是有区别的,不能混为一谈

- 分库:是为了解决数据库连接资源不足问题,和磁盘IO的性能瓶颈问题
- 分表:为了解决单表数据量太大,sql语句查询数据时,即使走了索引也非常耗时问题.此外还可以解决消耗cpu资源问题
- 如果在业务场景中,用户并发量很大,但是需要保存的数据量很少,这时可以只分库,不分表
- 如果在业务场景中,用户并发量不大,但是需要保存的数量很多,这时可以只分表,不分库
- 如果在业务场景中,用户并发量大,并且需要保存的数量也很多时,可以分库分表



## 池化技术



* 池化技术是`多例设计模式`的一个体现
* `创建`和`销毁`数据库连接是非常耗时耗资源的操作,如果每次用户请求,都要创建一个新的数据库连接,势必会影响程序的性能
* 为了提升性能,可以创建一批数据库连接,保存到内存中的某个集合中,缓存起来,以空间换时间
* 下次有需要用数据库连接时,就能直接从集合中获取,不用再额外创建数据库连接
* 用完之后,需要及时归还



## 读写分离



## 索引



## 批处理



## 集群



## 负载均衡



## 限流



### 对同一用户限流



### 对同一ip限流



### 对接口限流



### 验证码



## 服务降级



- Hystrix是Netflix开源的熔断降级组件
- Sentinel是阿里中间件团队开源的一款不光具有熔断降级功能,同时还支持系统负载保护的组件



## 故障转移



* Ribbon是一个负载均衡器组件,它可以检测服务的可用性,并根据一定规则将请求分发至不同的服务节点
  * 设置请求超时时间,当请求超时时,Ribbon会自动将请求转发到其他可用的服务上
  * 设置服务的健康检查,Ribbon会自动检测服务的可用性,并将请求转发至可用的服务上
* 此外,还需要使用`Hystrix`做熔断处理
* Hystrix是一个熔断器组件,它可以自动地监测所有通过它调用的服务,并在服务出现故障时自动切换到备用服务
  * 设置断路器的阈值,当故障率超过一定阈值后,断路器会自动切换到备用服务上
  * 设置服务的超时时间,如果服务在指定的时间内无法返回结果,断路器会自动切换到备用服务上,到其他的能够正常使用的服务器节点上



## 异地多活



## 压测



## 监控



* 目前业界使用比较多的开源监控系统是`Prometheus`,它提供了 `监控` 和 `预警` 的功能,可以用它监控如下信息:

  - 接口响应时间

  - 调用第三方服务耗时

  - 慢查询sql耗时

  - cpu使用情况

  - 内存使用情况

  - 磁盘使用情况

  - 数据库使用情况
  - 等等









