# Business



# 订单支付



![](img/001.png)



* 上图一个简化的下单流程,首先是提交订单,然后是支付
* 支付一般是走支付网关(支付中心),然后支付中心与第三方支付渠道(微信、支付宝、银联)交互
* 支付成功以后,异步通知支付中心,支付中心更新自身支付订单状态,再通知业务应用,各业务再更新各自订单状态
* 这个过程中经常可能遇到的问题是掉单,无论是超时未收到回调通知也好,还是程序自身报错也好
* 总之由于各种各样的原因,没有如期收到通知并正确的处理后续逻辑等等,都会造成用户支付成功了,但是服务端这边订单状态没更新
* 这个时候有可能产生投诉,或者用户重复支付
* 由于③⑤造成的掉单称之为外部掉单,由④⑥造成的掉单我们称之为内部掉单



## 支付掉单



* 支付订单增加一个中间状态支付中,当同一个订单去支付的时候,先检查有没有状态为支付中的支付流水,当然支付的时候要加个锁,支付完成以后更新支付流水状态的时候再讲其改成支付成功状态
* 支付中心这边要自己定义一个超时时间,在此时间范围内如果没有收到支付成功回调,则应调用接口主动查询支付结果,比如10s、20s、30s查一次,如果在最大查询次数内没有查到结果,应做异常处理
* 支付中心收到支付结果以后,将结果同步给业务系统,可以发MQ,也可以直接调用,直接调用的话要加重试
* 无论是支付中心,还是业务应用,在接收支付结果通知时都要考虑接口幂等性,消息只处理一次,其余的忽略
* 业务应用也应做超时主动查询支付结果
* 超时主动查询可以在发起支付的时候将这些支付订单放到一张表中,用定时任务去扫或者使用MQ



## 订单重复提交



* 创建订单时,用订单信息计算一个哈希值,判断redis中是否有key,有则不允许重复提交,没有则生成一个新key,放到redis中设置过期时间,然后创建订单



## 微信支付简易流程



![](img/002.png)



# 幂等性



* 数据库建立唯一性索引,可以保证最终插入数据库的只有一条数据
* token机制,每次接口请求前先获取一个token,然后再下次请求的时候在请求的header体中加上这个token,后台进行验证,如果验证通过删除token,下次请求再次判断token
* 悲观锁或者乐观锁,悲观锁可以保证每次for update的时候其他sql无法update数据(在数据库引擎是innodb的时候,select的条件必须是唯一索引,防止锁全表)
* 先查询后判断,首先通过查询数据库是否存在数据,如果存在证明已经请求过了,直接拒绝该请求,如果没有存在,就证明是第一次进来,直接放行



## Redis实现幂等



![](img/003.png)