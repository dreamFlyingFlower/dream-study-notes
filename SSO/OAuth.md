# OAuth2



# 概述



* OAuth2.0可以提供一个统一的认证服务,主要模块如下:
  * Resource Owner(RO):资源拥有者.拥有该资源的服务或用户,如我们自己或者资源网站
  * Authorization Server(AS):认证服务器.即用来认证与颁发令牌(如token)的服务
  * Resource Server(RS):资源服务器.拥有资源的服务,如我们要访问的网站
  * Client:客户端.即访问的客户端,如我们自己用的访问网站
  
* OIDC:OpenID Connect,Identity + Authentication + OAuth 2.0,它在OAuth2.0的基础上构建了一个身份层,其实就是客户端向认证服务器请求认证授权时多返回一个
  id_token,该 id_token 是一串使用 jwt 加密过的字符串

  ![](img/006.png)

  * OAuth2是一个授权协议,它无法提供完善的身份认证功能
  * OIDC使用OAuth2的授权服务器来为第三方客户端提供用户的身份认证,并把对应的身份认证信息通过一个叫id_token的东西传递给客户端
  * id_token使用JWT格式包装,使得id_token可以安全的传递给第三方客户端程序并且容易被验证
  * 如果id_token返回的内容不够,授权服务器还提供一个UserInfo接口,可以获取用户更完整的信息
  * 如果认证服务器开启了OIDC,可调用`http://ip:port/.well-known/openid-configuration`查询认证服务器信息

  ![](img/007.png)

* OAuth2.1:去掉了OAuth 2.0中的密码模式、简化模式,增加了设备授权码模式,同时也对授权码模式增加了 PKCE 扩展

* PKCE:Proof Key for Code Exchange,代码交换验证密钥.在授权码模式的交互工程中,有一个环节比较薄弱,这个环节就是用户在代理页面确认授权的时候,容易受到恶意程序的攻击,从而导致授权码被恶意程序窃取,进而通过授权码窃取令牌,当然这个前提也需要恶意程序已经植入到你的PC 或手机当中

  ![](img/005.png)

  * 为了减轻这种攻击,官方增加 PKCE 扩展
  * 客户端通过“/oauth2/authorize”地址向认证服务器发起获取授权码请求的时候增加两个参数，即 code_challenge 和code_challenge_method，其中，code_challenge_method 是加密方法（例如：S256 或plain），code_challenge 是使用 code_challenge_method 加密方法加密后的值
  * 认证服务器给客户端返回授权码，同时记录下 code_challenge、code_challenge_method 的值
  * 客户端使用 code 向认证服务器获取 Access Token 的时候，带上 code_verifier 参数，其值为步骤 A 加密前的初始值
  * 认证服务器收到步骤 C 的请求时，将 code_verifier 的值使用 code_challenge_method的方法进行加密，然后将加密后的值与步骤 A 中的 code_challenge 进行比较，看看是否一致。
  * 上面交互过程中,恶意程序如果在 B 处截获授权码后，使用授权码向认证服务器换取 Access Token，但由于恶意程序没有 code_verifier的值，因此在认证服务器无法校验通过，从而获取 Access Token 失败
  * 对于如何创建 code_challenge 的值，官网给出了如下方法:S256 code_challenge = BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))

* 



# 授权模式



* 授权码模式:authorization_code.适用于Web和移动应用程序.用户首先被重定向到授权服务器,授权服务器会要求用户授权应用程序访问其数据.如果用户同意授权,授权服务器会向应用程序颁发授权码.应用程序使用授权码向授权服务器请求访问令牌
* 客户端模式:client_credentials.适用于应用程序(服务器)之间的数据交换.应用程序使用自己的客户端 ID 和客户端密钥向授权服务器请求访问令牌.授权服务器验证客户端 ID 和客户端密钥后,向应用程序颁发访问令牌
* 密码模式:password,不安全.适用于应用程序需要直接从用户那里获取用户名和密码的情况.应用程序向授权服务器发送用户名和密码,授权服务器验证用户名和密码后,向应用程序颁发访问令牌
* 隐式授权模式:implicit,不安全.适用于不需要服务器端存储令牌的应用程序.用户被重定向到授权服务器,授权服务器要求用户授权应用程序访问其数据.如果用户同意授权,授权服务器会向应用程序颁发访问令牌,无需先获取授权码
* 设备授权模式:device,oauth2.1新模式
* 刷新模式:refresh_token.用刷新码获取



## 授权码



![](img/001.png)



* 先申请授权码code,得到code后再用来申请access_token

* 以QQ的AS(认证服务器)为例:

  * Client向用户展示,可以支持QQ、微信等第三方登录.用户选择QQ,则跳转至QQ登录界面,通常为WEB界面.此时,若用户未登录,则要求用户登录,若已登录,则询问是否授权,以及展示授权后会获得哪些权限
  * 用户点击授权,触发申请
  * 授权通过,QQ的AS将用户导向Client事先指定的重定向URI(redirection URI),同时附上一个code
  * Client收到code,附上早先的重定向URI,向AS申请access_token.这一步是在Client的后台的服务器上完成的,对用户不可见
  * AS核对了授权码和重定向URI,确认无误后,向Client发送访问令牌(access_token)和更新令牌(refresh_token)

* code只能使用一次,且有时间限制

* 申请code时,需要在URI的query中附加以下信息

  * response_type:REQUIRED.  Value MUST be set to "code"
  * client_id:REQUIRED.  The client identifier
  * redirect_uri:OPTIONAL
  * scope:OPTIONAL.  The scope of the access request
  * state:RECOMMENDED.  An opaque value used by the client to maintain state between the request and callback.  The redirecting the user-agent back to the client.  The parameter SHOULD be used for preventing cross-site request forgery

* code返回时,URI的query中的附加信息如下

  * code:REQUIRED.The authorization code generated by the authorization server.  The authorization code MUST of expire shortly after it is issued to mitigate the risk of leaks.  A maximum authorization code lifetime of 10 minutes is RECOMMENDED.  The client MUST NOT use the authorization code more than once.  If an authorization code is used more than once, the authorization server MUST deny the request and SHOULD revoke (when possible) 
    all tokens previously issued based on that authorization code.  The authorization code is bound to the client identifier and redirection URI
  * state:REQUIRED if the "state" parameter was present in the client authorization request.  The exact value received from the client

* 使用code申请access_token时,需要在HTTP request entity-body中提交以下信息

  * grant_type:REQUIRED.  Value MUST be set to "authorization_code"
  * code:REQUIRED.  The authorization code received from the authorization server
  * redirect_uri:REQUIRED, if the "redirect_uri" parameter was included in the authorization request, and their values MUST be identical
  * client_id:REQUIRED, if the client is not authenticating with the authorization server

* 申请成功后,授权服务器将返回access token和token有效时间,以及可选的refresh token

* eg

  ```
  GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
  Host: server.example.com
  
  Authorization Code Response：
  
  HTTP/1.1 302 Found
  Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA&state=xyz
  1
  2
  Request Access Token：
  
       POST /token HTTP/1.1
       Host: server.example.com
       Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
       Content-Type: application/x-www-form-urlencoded
  
       grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA
       &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
  
  Access Token Response：
  
       HTTP/1.1 200 OK
       Content-Type: application/json;charset=UTF-8
       Cache-Control: no-store
       Pragma: no-cache
  
       {
         "access_token":"2YotnFZFEjr1zCsicMWpAA",
         "token_type":"example",
         "expires_in":3600,
         "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
         "example_parameter":"example_value"
       }
  ```

  



## 客户端



* 该模式下,并不存在对个体用户授权的行为,被授权的主体为client.因此,该模式可用于对某类用户进行集体授权

* 请求

  * POST
  * grant_type:REQUIRED.Value MUST be set to "client_credentials"
  * scope:OPTIONAL.  The scope of the access request

* 响应

  * access_token:此次请求的token
  * token_type:token类型
  * expires_in:token有效时长,单位为秒

* eg:OAuth2.0

  ```
  Request：
  
       POST oauth/token HTTP/1.1
       Host: server.example.com
       Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
       Content-Type: application/x-www-form-urlencoded
  
       grant_type=client_credentials
       
  Response：
  
       HTTP/1.1 200 OK
       Content-Type: application/json;charset=UTF-8
       Cache-Control: no-store
       Pragma: no-cache
  
       {
         "access_token":"2YotnFZFEjr1zCsicMWpAA",
         "token_type":"example",
         "expires_in":3600
       }
  ```

* eg:OAuth2.1

  ```
  Request：
  
       POST /oauth2/token HTTP/1.1
       Host: server.example.com
       Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
       Content-Type: application/x-www-form-urlencoded
  
       grant_type=client_credentials
       
  Response：
  
       HTTP/1.1 200 OK
       Content-Type: application/json;charset=UTF-8
       Cache-Control: no-store
       Pragma: no-cache
  
       {
         "access_token":"2YotnFZFEjr1zCsicMWpAA",
         "token_type":"example",
         "expires_in":3600
       }
  ```

  



## 密码



![](img/003.png)



* 需要用户将自身的用户名和密码交由client,client将使用它们来申请access_token,用户信息会暴露.除非client十分可靠(例如硬件,系统APP),否则,不建议使用该模式

* 请求

  * POST
  * grant_type:REQUIRED.  Value MUST be set to "password"
  * username:REQUIRED.  The resource owner username
  * password:REQUIRED.  The resource owner password
  * scope:OPTIONAL.  The scope of the access request

* 响应

  * access_token:此次请求的token
  * token_type:token类型
  * expires_in:token有效时长,单位为秒
  * refresh_token:此次请求token过期时,下一次请求token时携带的token

* eg:

  ```
  Request：
  
       POST /token HTTP/1.1
       Host: server.example.com
       Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
       Content-Type: application/x-www-form-urlencoded
  
       grant_type=password&username=user11&password=123456
  
  Response：
  
       HTTP/1.1 200 OK
       Content-Type: application/json;charset=UTF-8
       Cache-Control: no-store
       Pragma: no-cache
  
       {
         "access_token":"2YotnFZFEjr1zCsicMWpAA",
         "token_type":"example",
         "expires_in":3600,
         "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA"
       }
  ```

  



## 隐式



![](img/004.png)



* 在授权码模式中,code和access_token都由授权服务器生成和验证,而最终只用到access_token,这让code显得无足轻重.因此,授权码简化模式,去掉了code的申请流程,从而通过User-Agent(Browser)直接申请access_token

* 以QQ的AS为例

  * Client向用户展示,可以支持QQ、微信等第三方登录.用户选择QQ,则跳转至QQ界面,通常为WEB界面.此时,若用户未登录,则要求用户登录,若已登录,则询问是否授权,以及展示授权后会获得哪些权限
  * 用户点击授权,触发申请
  * 授权通过,QQ AS将用户导向Client事先指定的重定向URI(redirection URI),同时附上access_token
  * QQ(User-Agent)收到重定向响应后,向Client提出请求,表示想提取URI中的access_token
  * Client返回带有解析脚本的页面,用于解析重定向URI fragment中的access_token
  * User-Agent使用解析脚本,获取access_token
  * User-Agent将access_token转交给Client

* 申请access_token时,需要在URI的query中附加以下信息

  * response_type:REQUIRED.  Value MUST be set to "token"
  * client_id:REQUIRED.  The client identifier
  * redirect_uri:OPTIONAL
  * scope:OPTIONAL. The scope of the access request
  * state:RECOMMENDED.  An opaque value used by the client to maintain state between the request and callback.  The authorization server includes this value when redirecting the user-agent back to the client.  The parameter SHOULD be used for preventing cross-site request forgery

* access_token返回时,URI的query中的附加信息如下

  * access_token:REQUIRED.  The access token issued by the authorization server
  * token_type:REQUIRED.  The type of the token issued.  Value is case insensitive
  * expires_in:RECOMMENDED.  The lifetime in seconds of the access token.  For example, the value "3600" denotes that the access token will expire in one hour from the time the response was generated. If omitted, the authorization server SHOULD provide the expiration time via other means or document the default value
  * scope:OPTIONAL, if identical to the scope requested by the client; otherwise, REQUIRED.  The scope of the access token
  * state:REQUIRED if the "state" parameter was present in the client authorization request.  The exact value received from the client

* eg

  ```
  Request:
  
  GET /authorize?response_type=token&client_id=s6BhdRkqt3&state=xyz&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
  Host: server.example.com
  
  Response:
  
  HTTP/1.1 302 Found
  Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA&state=xyz&token_type=example&expires_in=3600
  ```



## 设备授权码



* 是为解决不便在当前设备上进行文本输入而提供的一种认证授权模式.例如:智能电视、媒体控制台、数字相框、打印机等.使用设备授权码模式,有以下要求:
  * 该设备已连接到互联网
  * 设备能够支持发出 HTTPS 请求
  * 设备能够显示或以其他通信方式将 URI 和 Code 发给用户
  * 用户有辅助设备（如个人电脑或智能手机），他们可以从中处理请求
* 设备授权码登录官网交互图如下:
  * 客户端带上包含客户端信息的参数向认证服务器（地址：/oauth2/device_authorization）发起授权访问
  * 认证服务器给客户端返回设备码、用户码及需要用户验证用户码的 URI
  * 客户端指示用户需要在另一设备进行访问授权的 URI 和用户码
  * 用户根据 URI 打开页面，输入用户码和确认授权，向认证服务器发起认证请求
  * 客户端在完成步骤（C）之后就开始带上客户端信息和设备码向认证服务器轮询获取令牌信息
  * 认证服务器收到客户端使用设备码获取令牌信息的请求后，检查用户是否已提交授权确认，如果用户已提交授权确认，则返回令牌信息



## 拓展授权



* OAuth2.1 也提供拓展授权模式的操作实现。虽然 OAuth2.1移除了密码模式,但是通过拓展授权模式可以实现密码模式
* 在实际应用中，客户端、授权服务器、资源服务器往往都是同一家公司的产品，那么这个时候，使用账号、密码进行登录的情形也比较常见，此时就需要通过拓展授权模式来实现账号、密码登录了
* [官网文档](https://docs.spring.io/spring-authorization-server/docs/current/reference/html/guides/how-to-ext-grant-type.html)



# 客户端授权



* 用户通过当前客户端服务向第三方授权服务器申请授权,流程如下

  ![](img/008.png)

  * 用户通过客户端去访问一个受限的资源时,客户端会检测是否有登录信息,没有登录信息会重定向至第三方认证服务器去请求授权
  * 认证服务器检测是否有登录信息(检查session),检测到没有登录则重定向至认证服务器登录页面并返回给用户
  * 用户输入账号密码后提交,认证服务器认证成功后会重定向至自身授权接口,授权接口生成一个授权码code之后携带code重定向至客户端配置的redirect_uri
  * Security OAuth2 Client默认实现了一个处理认证服务器授权码回调的接口:`/login/oauth2/code/{registrationId}`,该接口会自动获取code
  * 客户端获取code之后,再调用认证服务器的授权接口获取access_token以及相关信息,用access_token换取用户信息
  * SpringSecurity会自动将access_token信息存入session中,以后再发起请求时会从session中获取token







